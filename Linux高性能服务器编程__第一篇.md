# Linux 高性能服务器编程——笔记

## 第1章 TCP/IP协议簇

1. 使用cat /etc/services命令查看所有知名应用层协议所使用的传输层服务。
2. 当发送端应用程序使用send（或write）函数向一个TCP连接写入数据时，内核中的TCP模块首先把这些数据复制到与该连接对应的TCP内核发送缓冲区中，然后调用IP模块提供的服务。
3. UDP无须为应用层数据保存副本。当一个UDP数据报被成功发送之后，UDP内核缓冲区中的该数据报就被丢弃了。若需重发，应用程序需要重新从用户空间将该数据报拷贝到UDP内核发送缓冲区中。
4. arp -a查看arp缓存 arp -d删除arp缓存 arp -s 添加arp缓存。
5. /etc/resolv.conf文件存放DNS服务器的IP地址。
6. host -t A www.baidu.com 向首选DNS服务器查询百度的IP地址。

## 第2章 IP协议详解

1. IP数据报可能在传输过程中多次分片，但只有在最终的目标机器上才会被最终组装。
2. IP头部选项字段
   - 记录路由
   - 时间戳
   - 松散源路由选择，指定一个路由器IP地址列表，数据报发送过程中必须经过期中所有的路由器。
   - 严格源路由选择，和松散源路由选择类似，不过数据报只能经过被指定的路由器。
3. route命令可以修改路由表。
4. 如何使主机可以转发数据包：将/proc/sys/net/ipv4/ip_forward内核参数设置为1。
5.  /proc/sys/net/ipv4/conf/all/send_redirects 内核参数指定是否允许发送ICMP重定向报文；/proc/sys/net/ipv4/conf/all/accecpt_redireacts内核参数指定是否允许接收ICMP重定向报文。一般来说==主机只能接收ICMP重定向报文，而路由器只能发送ICMP重定向报文==。

## 第3章 TCP协议详解

1. 基于广播和多播的应用程序不能使用TCP服务。

2. 由于TCP缓冲区的存在导致发送端执行的写次数和接收端执行的读次数之间没有任何数量关系。

3. TCP报头中的序号值由系统初始化为一个随机值ISN。

4. TCP头部选项（kind length info）
   - kind=0 选项表结束
   - kind=1 空操作，一般用于将TCP选项的总长度填充为4字节的整数倍。
   - kind=2 最大报文段长度选项(MSS), 以太网MSS值是1460(1500-20-20)。
   - kind=3 窗口扩大因子 头部中窗口大小的左移位数。可以修改/proc/sys/net/ipv4/tcp_window_scaling启用或关闭该选项。
   - kind=4 选择确认SACK。/proc/sys/net/ipv4/tcp_sack。
   - kind=5 SACK实际工作的选项。
   - kind=8 时间戳选项。
   
5. 服务器和客户端应用程序判断对方是否已经关闭连接的方法是：==read系统调用返回 0==。

   ![](image\图1.jpg)

6. iptable命令用于过滤数据包，可以用该命令模拟繁忙的服务器环境。

7. /proc/sys/net/ipv4/tcp_syn_retries定义超时重传的次数。

8. 客户端通过connect系统调用主动与服务器建立连接。connect系统调用可能因为两个原因失败返回。

   - connect连接的目标端口不存在，或该端口仍处于被TIME_WAIT状态的连接所占用。
   - 超时，未收到服务器的确认报文段。

9. 连接停留在FIN_WAIT_2状态的情况可能发生在：客户端执行半关闭后，未等服务器关闭连接就强行退出了。此时客户端连接由内核来接管，可称之为孤儿连接。Linux为了防止孤儿连接长时间存留在内核中，定义了两个内核变量：/proc/sys/net/ipv4/tcp_max_orphans和/proc/sys/net/ipv4/ tcp_fin_timeout。

10. TIME_WAIT状态，等待2MSL时间。

    - 可靠的终止TCP连接。防止确认报文丢失，服务器端重发FIN ACK报文。
    - 保证让迟来的TCP报文段由足够的时间被识别丢弃。当一个TCP连接处于TIME_WAIT状态时，无法立即使用该连接占用着的端口来建立一个新连接。如没有TIME_WAIT状态，则应用程序可以立刻建立一个和刚关闭的连接相似的连接，这个连接可能接收到属于原来连接的报文段。

11. 可以通过socket选项SO_REUSEADDR来强制进程立即使用处于TIME_ WAIT状态的连接占用的端口。

12. 应用程序可以使用socket选项SO_LINGER来发送复位(RST)报文段。

13. 半打开连接：客户端还维持着原来的连接，而服务器即使重启，也已经没有该连接的任何信息。

14. TCP报文段所携带的应用程序数据按照长度分为两种：交互数据和成块数据。交换数据仅包含很少的字节。使用交互数据的应用程序对实时性要求高，如telnet、ssh等。成块数据的长度则通常为TCP报文段允许的最大数据长度。使用成块数据的应用程序对传输效率要求高，如ftp。

15. 交互数据流

    - 延迟确认：不马上确认上次收到的数据，而是在一段延迟时间之后查看本端是否有数据需要发送，若有，则和确认消息一起发出。
    - Nagle算法要求一个TCP连接的通信双方在任意时刻都最多只能发送一个未被确认的TCP报文段。

16. 带外数据（OOB）：用于迅速通告对方本端发生的重要事件，比普通数据有更高的优先级，应该总是立即被发送。UDP没有实现带外数据传输，TCP也没有真正的带外数据。不过TCP利用其头部中的紧急指针标志和紧急指针两个字段，给应用程序提供了一种紧急方式。

    - 发送段一次发送的多字节的带外数据中只有最后一字节被当作带外数据，而其他数据被当成了普通数据。如果TCP模块以多个TCP报文段来发送所示TCP发送缓冲区中的内容，则每个TCP报文段都将设置URG标志，并且它们的紧急指针指向同一个位置，但只有一个TCP报文段真正携带带外数据。
    - TCP接收端只有在接收到紧急指针标志时才检查紧急指针，然后根据紧急指针所指的位置确定带外数据的位置，并将它读入一个特殊的缓存中。这个缓存只有1字节，称为带外缓存。如果上层应用程序没有及时将带外数据从带外缓存中读出，则后续的带外数据将覆盖它。
    - SO_OOBINLINE可以将带外数据和普通数据一样被TCP模块存放在TCP接收缓冲区中。

17. Linux有两个重要的内核参数与TCP超时重传相关：/proc/sys/net/ipv4/tcp _retries1和/proc/sys/net/ipv4/tcp_retries2。前者指定在底层IP接管之前TCP最少执行的重传次数，后者指定连接放弃前TCP最多可以执行的重传次数。

18. TCP报文的重传可以发生在超时之前，即快速重传。

19. 拥塞控制算法在Linux下有多种实现，比如reno算法、vegas算法和cubic算法等。/proc/sys/net/ipv4/tcp_congestion_control文件指示机器当前所使用的拥塞控制算法。

20. 拥塞控制的最终受控变量时发送端向网络一次连续写入的数据量，称为SWND(发送窗口)。不过发送端最终以TCP报文段来发送数据，所以SWND限定了发送端能连续发送的TCP报文段的数量。这些TCP报文段的最大长度称为SMSS(发送者最大段大小)，其值一般等于MSS。

21. 代理服务器按照使用方式和作用，分为正向代理服务器、反向代理服务器和透明代理服务器。

    - 正向代理服务器：要求客户端自己设置代理服务器的地址。客户的每次请求都将直接发送到该代理服务器，并由代理服务器来请求目标资源。
    - 反向代理服务器：设置在服务器端。用代理服务器来接收Internet上的连接请求，然后将请求转发给内部网络上的服务器，并从内部服务器上得到的结果返回给客户端。
    - 透明代理服务器只能设置在网关上，可以看成是正向代理的一种特殊情况。
    - 开源软件squid支持所有代理方式，varnish仅能用作反向代理。
    
22. 用户可以通过修改/etc/host.conf文件来自定义系统解析主机名的方法和顺序。

23. 请求方法中HEAD,GET,OPTIONS,TRACE所示安全的方法，因为它们只是从服务器获得资源或信息，而不对服务器进行任何修改。POST,PUT, DELETE,PATCH会影响服务器上的资源。

24. GET,HEAD,OPTIONS,TRACE,PUT和DELETE等请求方法是等幂的，多次连续的、重复的请求和只发送一次该请求具有完全相同的效果。而POST则不同。

25. 用HTTP头部中的Connection字段控制长短连接，长连接：keep-alive，短连接：close。

26. HTTP常见状态码

    ![](image\图2.jpg)
